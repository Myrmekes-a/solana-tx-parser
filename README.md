### Generated docs/metods description
[Generated module docs](/docs/README.md)

### What this tool can be used for?
- Parse solana instructions using anchor IDL/custom parsers.
- Parse `SystemProgram`, `TokenProgram`, `AssociatedTokenProgram` instructions out of the box.
- Parse transaction logs.
- Convert ParsedTransaction/CompiledTransaction/base64-encoded transaction into a list of TransactionInstructions and parse it.
- Unfold transaction with CPI into artificial transaction with CPI calls included as usual TransactionInstruction.

### Examples/How To Use
#### Parse by IDL
First step: init parser
```ts
import { PublicKey, Connection } from "@solana/web3.js";
import { SolanaParser } from "@debridge-finance/solana-transaction-parser";
import { IDL as JupiterIdl, Jupiter } from "./idl/jupiter"; // idl and types file generated by Anchor

const rpcConnection = new Connection("https://jupiter.genesysgo.net");
const txParser = new SolanaParser([{ idl: JupiterIdl as unknown as Idl, programId: "JUP2jxvXaqu7NQY1GmNF4m1vodw12LVXYxbFL2uJvfo" }]);
```
Second step: parse transaction by tx hash:
```ts
const parsed = await txParser.parseTransaction(
	rpcConnection,
	"5zgvxQjV6BisU8SfahqasBZGfXy5HJ3YxYseMBG7VbR4iypDdtdymvE1jmEMG7G39bdVBaHhLYUHUejSTtuZEpEj",
	false,
);
```
Voila! We have a list of TransactionInstruction with instruction names, args and accounts.
We can find instruction by name: 
```ts
const tokenSwapIx = parsed?.find((pix) => pix.name === "tokenSwap");
//or just use index
const setTokenLedgerIx = parsed[0] as ParsedIdlInstruction<Jupiter, "setTokenLedger">;
```
#### Parse with custom parser
What if the instructions we want to parse do not belong to Anchor program? 
We could provide custom instruction parser to SolanaParser!
Custom parser need to have following interface: `(instruction: TransactionInstruction): ParsedCustomInstruction`.
We've implemented a small program for testing purposes which can perform two actions: sum up two numbers (passed as u64 numbers) OR
print provided data to log (passed as ASCII codes and as a second account in accounts list).

| First byte | Action                                                                           |
| ---------- | -------------------------------------------------------------------------------- |
| 0          | Print remaining data as text + string "From: " + second account pubkey as base58 |
| 1          | Sum up two numbers and print the result to log                                   |

Parser will be really simple in such case:
```ts
function customParser(instruction: TransactionInstruction): ParsedCustomInstruction {
	let args: unknown;
	let keys: ParsedAccount[];
	let name: string;
	switch (instruction.data[0]) {
		case 0:
			args = { message: instruction.data.slice(1).toString("utf8") };
			keys = [instruction.keys[0], { name: "messageFrom", ...instruction.keys[1] }];
			name = "echo";
			break;
		case 1:
			args = { a: instruction.data.readBigInt64LE(1), b: instruction.data.readBigInt64LE(9) };
			keys = instruction.keys;
			name = "sum";
			break;
		default:
			throw new Error("unknown instruction!");
	}

	return {
		programId: instruction.programId,
		accounts: keys,
		args,
		name,
	};
}
```
Now we need to init SolanaParser object (which contains different parsers that can parse instructions from specified programs)
```ts
const parser = new SolanaParser([]);
parser.addParser(new PublicKey("5wZA8owNKtmfWGBc7rocEXBvTBxMtbpVpkivXNKXNuCV"), customParser);
```
To parse transaction which contains this instructions we only need to call `parseTransaction` method on parser object
```ts
const connection = new Connection(clusterApiUrl("devnet"));
const parsed = await parser.parseTransaction(connection, "2QU8jyEde9qbvtrYBJJZ2iBubqodmQRSoq2pfomHdGYgTgXwuncappiet8ojGGRdEkzkhW8sXdyfCxwuGHaHYegC");
// check if no errors was produced during parsing
if (!parsed) throw new Error("failed to get tx/parse!");
console.log(parsed[0].name); // will print "echo"
```